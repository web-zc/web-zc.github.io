<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>this指向</title>
      <link href="/2019/04/20/index/"/>
      <url>/2019/04/20/index/</url>
      
        <content type="html"><![CDATA[<h2 id="最近看了几篇有关this的博客总结下"><a href="#最近看了几篇有关this的博客总结下" class="headerlink" title="最近看了几篇有关this的博客总结下"></a>最近看了几篇有关this的博客总结下</h2><p><strong>前言：</strong></p><p>this指向一直令人头疼，每当自己快弄懂得时候，又来些奇怪的案例，一战回到解放前。</p><p>第一次写博客，谈一下现在对this的理解。</p><p>如果有不对的地方，欢迎大家指正。</p><p>一、this指向</p><ol><li><p><strong>普通函数调用</strong>  this是全局对象window   这个函数实质是window下的方法</p><pre><code>```javascript</code></pre><p>var x = 520<br>function test(){</p><pre><code>console.log(this.x) // 520</code></pre><p>}<br>test()</p><pre><code>```</code></pre></li><li><p><strong>函数作为对象的方法被调用</strong>  函数的this就是调用它的对象</p><pre><code>```javascript</code></pre><p>function test(){</p><pre><code>        console.log(this.x)    }    var obj = {}    obj.x = 1    obj.m = test    obj.m() // 1</code></pre></li></ol><pre><code>   ```</code></pre><ol start="3"><li><p><strong>构造函数</strong>  构造函数中this是实例化的对象</p><pre><code>```javascript</code></pre><p>function test(){</p><pre><code>       this.x = 520   }   var obj = new test()   obj.x  //520```</code></pre></li><li><p><strong>箭头函数</strong> 箭头函数的this是，上一作用域的this   且无法通过call方法改变this指向</p><pre><code>```javascript</code></pre><p>var arry = [1]</p><pre><code>   let x = 520   function test(){      arry.forEach(itme =&gt; {          console.log(this.x) // 520      })   }   test()```</code></pre><p><strong>对象中箭头函数</strong> 对象中箭头函数的this指向window</p><pre><code>```javascript</code></pre><p> var x = 520</p><pre><code>  var obj = {      x:1314,      y: ()=&gt;{          console.log(this.x) // 520      },      z: {         x: 1314,         d: ()=&gt;{             console.log(this.x) // 520         }      }  }  obj.y() // 对象中箭头函数this是window  obj.z.d() // 多层对象嵌套中的箭头函数的this还是window```</code></pre></li></ol><ol start="5"><li><p><strong>原型方法</strong> 原型方法中的this是实例对象</p><pre><code>```javascript</code></pre><p>function Test(){</p><pre><code>      this.x = 520   }   Test.prototype.test = function(){        console.log(this.x) //520   }   var foo = new Test()   foo.test()```</code></pre></li><li><p><strong>匿名函数</strong> 匿名函数中的this是window   匿名函数会自执行</p><pre><code>```javascript</code></pre><p> var x =520</p><pre><code>   function Test(){      var x = 1314     return function (){          console.log(this.x)  // 520      }   }      var z = new Test()      z()```</code></pre><hr></li></ol><p>二、改变this指向的方法</p><ul><li><p>call、apply、bind都属于Function.prototype的一个方法，所以每个function实例都有call、apply、bind属性</p><pre><code>```javascript</code></pre><p> var obj = {</p><pre><code>     b: function(x,y){         console.log(this)         console.log(x,y)     } } //以下所有调用都可以传递参数 obj.b(2,4) //obj obj.b.call(window,2,4) // window call与apply 都会返回新函数 obj.b.apply(window,[2,4]) // window obj.b.bind(window,2,4)() // window bind返回改变了上下文后的一个函数，要执行，还要调用```</code></pre></li><li><p>用变量或对象下的方法接收，会改变this指向</p><pre><code>```javascript</code></pre><p> var x = 1314</p><pre><code>    var obj = {        x: 520,        b: function () {            console.log(this.x)        }    }    var c = {        x: 666    }    obj.b()  //520      var q = obj.b  //用普通变量接收，this是window    q() // 1314    c.o = obj.b    //用对象下的一个方法接收this是该对象c    c.o() // 666```</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
